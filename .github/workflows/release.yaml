name: release

on:
  push:
    branches:
    - main

env:
  GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}
  GITHUB_OWNER: ${{ github.repository_owner }}

permissions: write-all

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: google-github-actions/release-please-action@v4
        id: release-please
        with:
          release-type: terraform-module
      - uses: actions/checkout@v4
      - uses: DeterminateSystems/nix-installer-action@main
      - uses: DeterminateSystems/magic-nix-cache-action@main
      - uses: nicknovitski/nix-develop@v1.1.0
        with:
          arguments: |
            --ignore-environment \
            --extra-experimental-features nix-command \
            --extra-experimental-features flakes \
            --keep HOME \
            --keep SSH_AUTH_SOCK \
            --keep GITHUB_TOKEN \
            --keep AWS_ROLE \
            --keep AWS_REGION \
            --keep AWS_DEFAULT_REGION \
            --keep AWS_ACCESS_KEY_ID \
            --keep AWS_SECRET_ACCESS_KEY \
            --keep AWS_SESSION_TOKEN \
            --keep TERM \
            ${{ github.workspace }}
# put release tests here
      # if using OICD auth
      - uses: aws-actions/configure-aws-credentials@v4
        if: ${{vars.AWS_AUTH == 'OIDC'}}
        with:
          role-to-assume: ${{secrets.AWS_ROLE}}
          role-session-name: ${{github.job}}-${{github.run_id}}-${{github.run_number}}-${{github.run_attempt}}
          aws-region: ${{secrets.AWS_REGION}}
      # if using access key auth
      - uses: aws-actions/configure-aws-credentials@v4
        if: ${{vars.AWS_AUTH == 'IAM'}}
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{secrets.AWS_REGION}}
      - uses: haythem/public-ip@v1.3
        id: ip_pre
      - uses: actions/cache/restore@v3
        id: cache-terraform-restore
        with:
          path: ${{ github.workspace }}/.terraform
          key: terraform-${{hashFiles('**/versions.tf','**/main.tf')}}
      - run: |
          echo "Planning..."

          echo "Setting up env..."
          if [ "" = '${{secrets.AGE_SECRET_KEY}}' ]; then echo "Missing encrypt key, please run repo setup before release."; exit 1; fi
          if [ ! -f age_recipients.txt ]; then echo "Missing encryption recipients, please run repo setup before release."; exit 1; fi

          while read -r file; do
            echo '${{secrets.AGE_SECRET_KEY}}' | age -d -i - -o "$file" "$file.age"
          done <secret_file_list.txt
          eval "$(ssh-agent -s)"
          chmod 0600 ssh_key
          ssh-add ssh_key
          export TF_VAR_ip="${{ steps.ip_pre.outputs.ipv4 }}"

          ls -lah

          echo "Deploy ci security group access..."
          terraform init -upgrade
          # manage the security group rule for the terraform runner as a separate entity to prevent dependency chain issues with server object
          # this is a hack for the basic example, normally you would manage access as a separate terraform config
          terraform apply --auto-approve -target=module.aws_rke2_rhel9_rpm.module.aws_access.module.security_group.aws_vpc_security_group_egress_rule.to_ip[0] || true
          terraform apply --auto-approve -target=module.aws_rke2_rhel9_rpm.module.aws_access.module.security_group.aws_vpc_security_group_ingress_rule.from_ip[0] || true

          echo "Terraform Plan..."
          terraform plan

          echo "clear out the CI security group access by replacing with a nonsense IP..."
          export TF_VAR_ip="192.168.1.1"
          terraform apply --auto-approve -target=module.aws_rke2_rhel9_rpm.module.aws_access.module.security_group.aws_vpc_security_group_egress_rule.to_ip[0] || true
          terraform apply --auto-approve -target=module.aws_rke2_rhel9_rpm.module.aws_access.module.security_group.aws_vpc_security_group_ingress_rule.from_ip[0] || true

          echo "Updating state..."
          rm -rf terraform.tfstate.age && age -e -R age_recipients.txt -o terraform.tfstate.age terraform.tfstate && rm -f terraform.tfstate

          echo "Removing secret files..."
          while read -r file; do
             rm -f "$file"
          done <secret_file_list.txt

          echo "Saving state..."
          git config --global user.name 'automation'
          git config --global user.email 'automation@users.noreply.github.com'
          git remote set-url origin "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{github.repository}}"
          git add terraform.tfstate.age
          git commit -s -m "New State https://github.com/${{github.repository}}/actions/runs/${{github.run_id}}"
          git push origin main
      - uses: actions/cache/save@v3
        id: cache-terraform-save
        with:
          path: ${{ github.workspace }}/.terraform
          key: ${{ steps.cache-terraform-restore.outputs.cache-primary-key }}
# these are only run after release is created
      # if using OICD auth
      - uses: aws-actions/configure-aws-credentials@v4
        if: ${{vars.AWS_AUTH == 'OIDC'}}
        with:
          role-to-assume: ${{secrets.AWS_ROLE}}
          role-session-name: ${{github.job}}-${{github.run_id}}-${{github.run_number}}-${{github.run_attempt}}
          aws-region: ${{secrets.AWS_REGION}}
      # if using access key auth
      - uses: aws-actions/configure-aws-credentials@v4
        if: ${{vars.AWS_AUTH == 'IAM'}}
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{secrets.AWS_REGION}}
      - uses: haythem/public-ip@v1.3
        id: ip
        if: steps.release-please.outputs.release_created
      - name: Apply
        if: steps.release-please.outputs.release_created
        shell: bash
        run: |
          echo "Setting up env..."
          if [ "" = '${{secrets.AGE_SECRET_KEY}}' ]; then echo "Missing encrypt key, please run repo setup before release."; exit 1; fi
          if [ ! -f age_recipients.txt ]; then echo "Missing encryption recipients, please run repo setup before release."; exit 1; fi
          while read -r file; do
            echo '${{secrets.AGE_SECRET_KEY}}' | age -d -i - -o "$file" "$file.age"
          done <secret_file_list.txt
          eval "$(ssh-agent -s)"
          chmod 0600 ssh_key
          ssh-add ssh_key
          export TF_VAR_ip="${{ steps.ip.outputs.ipv4 }}"

          echo "Starting  deploy..."
          terraform init
          # this is a hack for the basic example, normally you would manage access as a separate terraform config
          terraform apply --auto-approve -target=module.aws_rke2_rhel9_rpm.module.aws_access.module.security_group.aws_vpc_security_group_egress_rule.to_ip[0] || true
          terraform apply --auto-approve -target=module.aws_rke2_rhel9_rpm.module.aws_access.module.security_group.aws_vpc_security_group_ingress_rule.from_ip[0] || true
          terraform apply --auto-approve || true
          sleep 5

          echo "clear out the CI security group access by replacing with a nonsense IP..."
          export TF_VAR_ip="192.168.1.1"
          terraform apply --auto-approve -target=module.aws_rke2_rhel9_rpm.module.aws_access.module.security_group.aws_vpc_security_group_egress_rule.to_ip[0] || true
          terraform apply --auto-approve -target=module.aws_rke2_rhel9_rpm.module.aws_access.module.security_group.aws_vpc_security_group_ingress_rule.from_ip[0] || true
          rm -f ssh_key

          echo "Updating state..."
          rm -rf terraform.tfstate.age && age -e -R age_recipients.txt -o terraform.tfstate.age terraform.tfstate && rm -f terraform.tfstate

          echo "Removing secret files..."
          while read -r file; do
             rm -f "$file"
          done <secret_file_list.txt

          echo "Saving state..."
          git config --global user.name 'automation'
          git config --global user.email 'automation@users.noreply.github.com'
          git remote set-url origin "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{github.repository}}"
          git add terraform.tfstate.age
          git commit -s -m "New State https://github.com/${{github.repository}}/actions/runs/${{github.run_id}}"
          git push origin main
